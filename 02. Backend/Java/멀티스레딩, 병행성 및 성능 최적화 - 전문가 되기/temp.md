부가 리소스 - 이미지 처리, 색 공간, 추출 및 조작
여러분께 항상 가장 관련성이 높고 실제와 가까운 예시를 보여 드리려는 노력의 일환으로, 이전 강의에서는 색 공간, 비트 시프트, 이진 대수 등 멀티스레딩 이외의 다른 중요한 주제에 대해서도 조금 다뤄 보았습니다. 해당 주제들은 업계(및 취업 면접)에서 굉장히 자주 쓰이기 때문에, 본 가이드를 통해 이미지 처리 파트에 대해 더 자세히 설명해드리려 합니다.

픽셀 및 색 공간 배경
디지털 이미지에서 픽셀이란 화면에 표시되는 그림의 가장 작은 요소를 나타냅니다.

이미지는 2차원적인 픽셀의 집합에 불과하죠.

픽셀의 색상은 다양한 방법으로 인코딩됩니다.

자주 사용되는 픽셀 색상 인코딩 그룹은 다음과 같습니다.

Y'UV - 루마(밝기) 및 2개의 크로마(색상) 컴포넌트

RGB - 빨강, 초록, 파랑

HSL and HSV - 색조, 채도, 밝기/명도

CIE XYZ  - 장비 독립적인 빨강, 초록, 파랑

ARGB 메모리 표현
이미지 처리 예시에서 사용된 양식은 ARGB라는 RGB 방식의 한 버전으로, 여기서 A는 alpha, 즉, 알파(투명도)를 뜻합니다.

메모리에서 이 색상은 다음과 같이 표현됩니다.


보시다시피, 각 컴포넌트는 1바이트(8비트)를 나타내므로 각 컴포넌트의 값은 0(16진법으로 0x)에서 255(16진법으로 0xFF) 사이의 범위에 해당합니다.

우리에게는 4바이트가 주어졌기 때문에, 한 픽셀의 전체 색상을 int 유형의 변수에 저장할 수 있습니다.

컴포넌트 추출 코드 설명하기
이미지 처리 예시를 보시면 한 픽셀의 개별 컴포넌트를 추출하는 다음과 같은 메서드가 있습니다.

public static int getRed(int rgb) {
    return (rgb & 0x00FF0000) >> 16;
}
 
public static int getGreen(int rgb) {
    return (rgb & 0x0000FF00) >> 8;
}
 
public static int getBlue(int rgb) {
    return rgb & 0x000000FF;
}
각 색상 컴포넌트를 추출하는 연산을 위주로 각 매서드를 설명해드리겠습니다.

특정 컴포넌트(빨강, 초록, 혹은 파랑)를 추출하려면, 우선 해당 픽셀에서 원하는 컴포넌트만 남기고 다른 색상 컴포넌트는 모두 제거해야 합니다.

이를 위해서 우리는 비트마스크를 적용합니다.

비트마스크는 어떤 비트를 남기고, 어떤 비트를 제거할지를 정의하는 역할을 합니다.

0x00(2진법으로 0000 0000)을 사용하면 컴포넌트를 제거할 수 있습니다. 모든 X에 대해, X AND 0 = 0이 성립하기 때문이죠.

비트 단위 AND와 0xFF(2진법으로 1111 1111)을 사용하면 컴포넌트의 값을 남길 수 있습니다. 모든 X에 대해 X AND 1 = X가 성립하기 때문입니다.




하지만, 비트마스크를 적용했다고 끝이 아닙니다. 아직 컴포넌트를 나타내는 바이트를 가장 낮은 바이트로 시프트하는 단계가 남아 있습니다.

예를 들어 getRed(..) 메서드의 경우, 0x76543210에 비트마스크를 적용하게 되면 0x00540000이라는 결과를 얻게 되지만, 정작 필요한 값은 0x00000054입니다.

따라서 비트마스크의 결과값에 있는 모든 비트를 >> 연산자를 이용해 오른쪽으로 시프트해야 합니다.

파란색을 추출하는 경우에는 시프트 작업을 수행할 필요가 없습니다. 파랑은 이미 가장 오른쪽에 위치한 바이트에 해당하기 때문이죠.

초록색을 추출하는 경우에는 모든 비트를 오른쪽으로 1바이트(8비트) 옮겨야 합니다.

빨간색을 추출하는 경우에는 모든 비트를 오른쪽으로 2바이트(16비트) 옮겨야 합니다.

색상 컴포넌트를 픽셀과 결합하기
픽셀의 색상을 별도의 빨강, 초록, 파랑 컴포넌트를 통해 구축하려는 경우, 다음과 같은 메서드가 있습니다.

public static int createRGBFromColors(int red, int green, int blue) {
    int rgb = 0;
 
    rgb |= blue;
    rgb |= green << 8;
    rgb |= red << 16;
 
    rgb |= 0xFF000000;
 
    return rgb;
}
상기한 코드에서는 색상 컴포넌트 추출 작업의 반대 작업을 수행하고 있습니다. 각 컴포넌트를 가져다가 ARGB 픽셀 표현에서 해당되는 위치로 시프트하는 작업이죠.

파란색은 가장 낮은 바이트에 위치하므로, 픽셀 색상 표현을 파랑 컴포넌트로 비트 단위 OR 처리해 주면 됩니다.

초록색은 두 번째 바이트에 위치해야 하므로, 왼쪽으로 1바이트(8비트) 이동시킨 뒤, 픽셀 색상으로 비트 단위 OR 처리합니다.

이와 유사하게, 빨간색은 세 번째 바이트에 위치해야 하므로, 빨강 컴포넌트를 왼쪽으로 2바이트(16비트) 이동시킨 다음, 픽셀 색상으로 비트 단위 OR 처리합니다.


마지막 단계는 투명도 수준을 최고로 설정해서, 색상을 완전히 투명하게 만드는 것입니다(레벨 0은 완전히 투명하다는 뜻이고, 레벨 255는 완전히 불투명하다는 뜻입니다).

이 작업은 가장 왼쪽에 위치한 알파 컴포넌트 바이트를 2진법으로 1111 1111에 해당하는 0xFF로 설정하면 완료됩니다.

