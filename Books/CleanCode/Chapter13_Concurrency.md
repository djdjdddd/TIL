# 13장 동시성

### 개요

동시성과 clean code는 양립하기 어렵다. 아주 어렵다.

이 장에서는 다음에 대해 다룬다.
1. 여러 스레드를 동시에 돌리는 이유
2. 여러 스레드를 동시에 돌리는 어려움
3. 그럼에도 clean code를 작성하는 방법 몇 가지
4. 동시성을 테스트하는 방법과 문제점

더 자세한 내용은 407쪽 "동시성 2"에서 설명한다.

### 동시성이 필요한 이유?

1. 애플리케이션의 구조적 개선
    - 무엇과 언제를 분리하면 애플리케이션의 구조와 효율이 극적으로 나아진다.
2. 성능 개선 (ex. 응답 시간, 작업 처리량 개선 등)

동시성은 결합(coupling)을 없애는 전략이다. 즉, 무엇(what)과 언제(when)를 분리하는 전략이다. 당연히 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다.

#### (1) 동시성과 관련된 미신과 오해

1. **동시성은 항상 성능을 높여준다.**
    - 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다. 두 경우 모두 드문 편이다.
2. **동시성을 구현해도 설계는 변하지 않는다.**
    - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 왜냐하면 무엇과 언제를 분리하기 때문이다.
3. 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.


#### (2) 동시성과 관련된 타당한 생각

1. 동시성은 다소 부하를 유발한다.
2. 동시성은 복잡하다.
3. **일반적으로 동시성 버그는 재현하기 어렵다.** (그래서 일회성 문제로 여겨 무시하기 쉽다.)
4. 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

### 라이브러리를 이해하라

자바 5는 동시성 측면에서 이전 버전보다 많이 나아졌다. 자바 5로 스레드 코드를 구현한다면 다음을 고려하자

#### 스레드 환경에 안전한 컬렉션

|종류|설명|
|---|---|
|ReentrantLock | 한 메서드에서 잠그고 다른 메서드에서 푸는 락이다.|
|Semaphore | 전형적인 세마포. 개수(count)가 있는 락이다.|
|CountDownLatch | 지정한 수만큼 이벤트가 발생하고 나서야 대기 중인 스레드를 모두 해제하는 락이다. 모든 스레드에게 동시에 공평하게 시작할 기회를 준다.|

### 실행 모델을 이해하라

#### 기본 용어

| 용어                      | 설명                                                                                                        |
|-------------------------|-----------------------------------------------------------------------------------------------------------|
| Bound Resource(한정된 자원)  | 다중 스레드 환경에서 사용하는 자원으로 크기나 숫자가 제한적이다. (ex. DB Connection, 길이가 일정한 Reader/Writer Buffer 등                   |
| Mutual Exclusion(상호 배제) | 한번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.                                                               |
| Starvation(기아)          | 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. (ex. 항상 짧은 스레드에게 우선순위를 줄 때 그 스레드가 지속적으로 이어진다면 긴 스레드는 기아 상태에 빠진다) |
| Deadlock(데드락)           | 여러 스레드가 서로 끝나기를 기다리는 것.                                                                                   |
| Livelock(라이브락)          | 락을 거는 단게에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해 굉장히 오랫동안 혹은 영원히 진행하지 못한다.              |

#### 다중 스레드 프로그래밍에서 사용하는 실행 모델 몇 가지
1. Producer-Consumer(생산자-소비자)
2. Readers-Writers(읽기-쓰기)
3. Dining Philosophers(식사하는 철학자들)

### 공유 객체 하나에는 메서드 하나만 사용하라

자바 언어는 개별 메서드를 보호하는 synchronized 개념을 지원하지만, 공유 클래스 하나에 동기화된 메서드가 여럿이라면 찾아내기 어려운 버그가 생길 수 있다.

그럼에도 공유 객체 하나에 여러 메서드가 필요한 상황이 생긴다면 다음 3가지 방법을 고려하자.
1. 클라이언트에서 잠금
    - 클라이언트에서 첫번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지한다.
2. 서버에서 잠금
    - 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현한다. 클라이언트는 이 메서드를 호출한다.
3. 연결(Adapted) 서버
    - 잠금을 숭핸하는 중간 단계를 생성한다. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않는다.

### 동기화하는 부분을 최대한 작게 만들어라

자바에서 synchronized 키워드로 락을 설정할 수 있고, **이렇게 설정된 코드 영역은 한번에 한 스레드만 실행이 가능**하다.
따라서 이렇게 동기화(synchronized)된 영역을 최소화하여 애플리케이션 성능에 무리가 가지 않도록 하자.